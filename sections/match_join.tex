\subsection{Pipeline Join on Compressed Data}\label{sec:match_join}
%% By far, we've got all the compressed matching results for stars and it's time to join them to obtain the final answer.
%% A simple and straightforward method is the binary join, however, intermediate join results have to be materialized by doing so.
%% Even though the compression ratio of star matching result is very impressive,
%% the joined result could expand significantly because the permutation among roots is unavoidable~\cite{DBLP:journals/pvldb/SunWWSL12}.
%% To address this problem, we propose a indexed pipeline join algorithm on compressed data:
SeqStar reduces the memory usage further by performing pipeline join on compressed data.

To boost the join operation, we design an index on the SuperRow data.
Consider the SuperRow layout in Figure~\ref{img:compress}, each SuperRow contains only one root.
The uniqueness of the root makes it possible to be the key of a index (SuperRow-index):
Given a root ID, it returns the position of the corresponding SuperRow.
Since the vertices are sorted in the storage engine,
the SuperRow-index can be build by appending after a SuperRow is stored.
And the SuperRow-index operates by a simple binary search.

The planner of SeqStar first generate a join order based on the statistical parameters of SuperRows,
i.e., row number, average size of image sets.
The parameters are accumulated when a SuperRow is appended, and the cost is trivial.
Also note that in Algorithm~\ref{alg:decompose_stars}, the chosen root vertices form a connected vertex-cover.
The join order ensures the root of the stars are bound by previous stars.
For example, $T_1 \Join T_2 \Join \cdots \Join T_c$ (the discussion can be generalized to other join orders),
where $T_i$ is the SuperRows of $S_i$, and the root of $S_i$ is $u_i$.
SeqStar ensures $u_i \in V(S_{i-1})$ such that the Super-indexes will always work.

After that, SeqStar performs a pipeline join on the SuperRows to avoid materializing intermediate results.
The basic structure of the algorithm is a series of nested loops  (Algorithm~\ref{alg:join}).
The planner of SeqStar creates the context to guides the executor to perform the loops.
The executor uses a stack to record the vertices $v_1, v_2, \dots, v_c$ and the references of SuperRows $sr_1, sr_2, \dots, sr_c$.

\begin{algorithm}[ht]
  \caption{Pipeline Join}\label{alg:join}
  \SetKw{Yield}{yield}
  \ForEach{$sr_1 \in T_1$}{
    $v_1 \leftarrow sr_1[u_1]$\;
    \ForEach{$v_2 \in sr_1[u_2]$}{
      \If{$sr_2 \leftarrow T_2.idx(v_2)$}{
        \ForEach{$v_3 \in \bigcap_{u_3 \in S_i, i < 3}sr_i[u_3]$}{
          $\cdots$\;
          \If{$sr_c \leftarrow T_c.idx(v_c)$}{
            \Yield{$(v_1, \dots, v_c, \bigcap_{u_{c+1}\in S_i}sr_i[u_{c+1}], \dots)$}\;
          }
        }
      }
    }
  }
\end{algorithm}

Unlike the traditional join problem, SeqStar joins on image sets rather than single elements.
That is to say set intersection is the most computation-intensive operation.
Since vertices are sorted in the storage engine,
the order will still preserves in every image sets.
This property makes it perfect for the merge algorithm to perform set intersection.

To obtain the final results, decompression is done by performing Cartesian production on the yielded results.
Since the pipeline join is performed in a stream manner, the decompression can be done only if required.
Note that a unique operation is required for vertices in the same equivalence class.
For example, $(1, 2, 3, 4)$ is a valid matching for $(u_1, u_2, u_3, u_4)$ but $(1, 2, 2, 4)$ is not (Figure~\ref{img:running_example}).

%% Consider the SuperRows in Figure~\ref{img:running_example}, whose columns are image set for \textsc{NeighborInfo} equivalence class except the first column, which is the matching result of the root.
%% Thus the first column of a SuperRow contains only a single vertex, which is suitable for the key of a index.
%% In fact, the index is generated during the star matching process,
%% for each SuperRow we append the root id and the position of it to the index file.
%% With this index, we are able to locate to the corresponding SuperRows efficiently during the join process.

%% The basic structure of our pipeline join is a series of nested loops.
%% However, unlike the traditional join problem, we join on image sets rather than single elements,
%% which means set intersection is the most computation intensive operation.
%% Consider the social media network, a trending media could easily attract millions or even billions of viewers,
%% to join on such trending media rooted stars, we must calculate the set intersection of such enormous viewers.
%% A conventional hash join method could easily eat up the memory of a PC and have poor locality.
%% To address this problem, we provide an out-of-core sequential approach by merging on the image sets.
%% Therefore the image sets should be sorted otherwise the sorting operation could be another bottleneck.
%% In fact, with the elegant design of our vertex-centric property graph storage method,
%% the vertices are already sorted in the data graph, and we can implement our sequential out-of-core set intersection for free.
