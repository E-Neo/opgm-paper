\section{Experiments}\label{sec:experiments}
\subsection{Experiment Environment}
\subsubsection*{Hardware}
\subsubsection*{Data Set}
\subsubsection*{Queries}
\subsection{Comparison with Existing Work}
\subsubsection{Supported Features}
Table~\ref{tab:features}.
\begin{table*}[ht]
  \centering
  \begin{tabular}{ccccccc}
    \toprule
    Algorithm & Environment & Direction & Vertex Label & Edge Label & Multigraph & WHERE Clause \\
    \midrule
    opgm & Out-of-core & {\color{green}\Checkmark} & {\color{green}\Checkmark} & {\color{green}\Checkmark} & {\color{green}\Checkmark} & {\color{green}\Checkmark} \\
    Neo4j & DBMS & {\color{green}\Checkmark} & {\color{green}\Checkmark} & {\color{green}\Checkmark} & {\color{green}\Checkmark} & {\color{green}\Checkmark} \\
    STwig & Distributed & & {\color{green}\Checkmark} & & & \\
    \bottomrule
  \end{tabular}
  \caption{Comparisons of supported features (TODO).}\label{tab:features}
\end{table*}
\subsubsection{Overall Performance}
\begin{itemize}[noitemsep]
\item Compare the runtime with others to show that we have a good overall performance.
\item Compare the runtime with different memory limits where many others fail to run to show that we don't have to consume a lot of memory resources.
\end{itemize}
\subsection{Study of the Data Graph Scanning}
\subsubsection{Study of Data Graph Storage Method}
\begin{itemize}[noitemsep]
\item Compare with the conventional CSR/CSC method that stores in-edges and out-edges separately to show that our method is efficient for property graph matching problem.
\item Compare with the naive method that do not use the index for \textsc{VertexIter} to show that the index is effective.
\item Compare with the naive method that do not use the index for \textsc{NeighborIter} to show that the index is effective.
\end{itemize}
\subsubsection{Study of Star Matching}
\begin{itemize}[noitemsep]
\item Compare with Neo4j and naive method (match and filter on the final results) to show that our local constraint pushdown method is effective.
\item Compare with STwig's star decomposition algorithm to show that our algorithm can reduce the size of useless matching results, and also show that this optimization can propagate to the join phase that the CPU and I/O cost of join is also reduced.
\item Redirect the matching result to a sink and plot the I/O bandwidth over time to show that the data graph is read sequentially.
\end{itemize}
\subsection{Study of Compression}
\begin{itemize}[noitemsep]
\item Compare with naive method that do not compress at all to show that the compression ratio is significant.
\item Compare with naive method that do not consider equivalence classes (star matching \& join) to show that the equivalence classes can reduce the size of matching results.
\item Plot the I/O bandwidth (star matching \& join) over time to show that random disk access is avoided.
\end{itemize}
\subsection{Study of Join}
\begin{itemize}[noitemsep]
\item Compare with PostgreSQL to show that the join on compressed data is more efficient.
\item Compare with hash table set intersection algorithm to show that our join algorithm is more efficient,
  and it is better to find some data set where the image set is so large that the hash table set interaction is not runnable.
\item Compare with naive method that do not use index to show that our index is simple but effective.
\item Compare with naive method that do not use global constraint to show that the global constraint pushdown algorithm is effective.
\item Redirect the join results to sink and plot the disk bandwidth over time to show that the read of the join operation is sequential.
\end{itemize}
